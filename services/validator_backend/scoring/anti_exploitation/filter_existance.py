from transformers import AutoTokenizer, AutoModelForCausalLM, DynamicCache
from typing import List
import random
from semantic_text_splitter import TextSplitter
from copy import deepcopy
from datasets import load_dataset
from typing import Tuple
from ..utils import generate_answer
import re
import structlog

logger = structlog.get_logger("filter_existance")


class FilterExistanceChecker:
    def _check_text_exists(
        self,
        tokenizer: AutoTokenizer,
        model: AutoModelForCausalLM,
        kv_cache: DynamicCache,
        query_chunk: str,
        context_length: int,
    ) -> bool:
        _kv_cache = deepcopy(kv_cache)
        prompt = f"""
You are a precise and objective fact-checker. Your task is to determine whether the following quoted text appears in the provided context or is a direct paraphrase of it. 

Instructions:
- Consider the context to include information that might have been rephrased but retains the original meaning.
- Return 'yes' if the quoted text appears or is a clear paraphrase of the context.
- Return 'no' if the quoted text does not appear or if it is not a valid paraphrase.
- Your response should contain exactly one word: either 'yes' or 'no'. No additional text or explanations are required.

Quote:
```
{query_chunk}
```
[/INST] """
        logger.info(f"Filter Prompt: {prompt}")
        prompt_ids = tokenizer.encode(
            prompt,
            return_tensors="pt",
            add_special_tokens=False,
        )
        completion_text = generate_answer(
            model=model,
            tokenizer=tokenizer,
            question_ids=prompt_ids,
            cache=_kv_cache,
            context_length=context_length,
            max_new_tokens=8,
        )
        logger.info(f"Filter Completion: {completion_text}")
        # Split response into words and clean up
        words = re.findall(r"\b\w+\b", completion_text.lower())
        return "yes" in words, "no" in words or "not" in words

    def filter_existance(
        self,
        tokenizer: AutoTokenizer,
        model: AutoModelForCausalLM,
        kv_cache: DynamicCache,
        positive_chunks: List[str],
        negative_chunks: List[str],
        context_length: int,
    ) -> float:
        positive_accuracies = []
        for positive_chunk in positive_chunks:
            exist_yes, exist_no = self._check_text_exists(
                tokenizer, model, kv_cache, positive_chunk, context_length
            )
            if not exist_yes or (exist_yes and exist_no):
                positive_accuracies.append(0)
            else:
                positive_accuracies.append(1)
        if not any(positive_accuracies):
            logger.info(f"All positive existance check failed: {positive_accuracies}")
            return 0
        negative_accuracies = []
        # Test on negative case (text not from conversation)
        for negative_chunk in negative_chunks:
            exist_yes, exists_no = self._check_text_exists(
                tokenizer, model, kv_cache, negative_chunk, context_length
            )
            if not exists_no or (exist_yes and exists_no):
                negative_accuracies.append(0)
            else:
                negative_accuracies.append(1)
        if not any(negative_accuracies):
            logger.info(f"All negative existance check failed: {negative_accuracies}")
            return 0
        accuracies = positive_accuracies + negative_accuracies
        logger.info(f"Filter Existance Accuracy: {accuracies}")
        return sum(accuracies) / len(accuracies)
